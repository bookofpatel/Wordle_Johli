<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Wordle Sequence ‚Äî JHOLI ‚Üí PRAYAGRAJ ‚Üí DAN</title>
  <style>
    :root{
      --bg:#0f172a;
      --panel:#111827;
      --text:#e5e7eb;
      --muted:#94a3b8;
      --tile:#1f2937;
      --border: rgba(148,163,184,0.22);
      --border2: rgba(148,163,184,0.18);
      --hint: rgba(56,189,248,0.85);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(1200px 700px at 50% -10%, #1f2a44 0%, var(--bg) 55%);
      color:var(--text);
      display:flex;
      min-height:100vh;
      align-items:center;
      justify-content:center;
      padding:24px;
    }
    .app{
      width:min(860px, 100%);
      background: rgba(17,24,39,0.86);
      border:1px solid rgba(148,163,184,0.25);
      border-radius:18px;
      padding:18px 18px 20px;
      box-shadow: 0 18px 60px rgba(0,0,0,0.45);
      backdrop-filter: blur(10px);
    }
    header{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:12px;
      padding:6px 6px 14px;
      border-bottom:1px solid var(--border2);
      margin-bottom:14px;
      flex-wrap:wrap;
    }
    h1{font-size:18px; margin:0; letter-spacing:0.6px}
    .sub{font-size:12px; color:var(--muted)}
    .pill{
      font-size:12px;
      padding:6px 10px;
      border:1px solid var(--border);
      border-radius:999px;
      color:var(--text);
      background: rgba(15,23,42,0.55);
      font-weight:700;
    }

    #grid { margin-top: 10px; }
    .row{
      display:grid;
      gap:10px;
      margin:10px 0;
    }
    .tile{
      aspect-ratio: 1 / 1;
      display:flex;
      align-items:center;
      justify-content:center;
      background: var(--tile);
      border:1px solid var(--border);
      border-radius:12px;
      font-size:28px;
      font-weight:800;
      text-transform:uppercase;
      user-select:none;
      transition: transform .08s ease, background .18s ease, border-color .18s ease, box-shadow .18s ease;
    }
    .tile.pop{ transform: scale(1.04); }
    .tile.correct{ background:#16a34a; border-color:#22c55e; color:white; }
    .tile.present{ background:#ca8a04; border-color:#eab308; color:white; }
    .tile.absent{ background:#334155; border-color:#475569; color:#e2e8f0; }
    .tile.hinted{
      border-color: var(--hint);
      box-shadow: 0 0 0 2px rgba(56,189,248,0.18) inset;
    }

    .keyboard{ margin-top:14px; display:grid; gap:8px; }
    .kb-row{display:flex; gap:8px; justify-content:center; flex-wrap:nowrap;}
    button.key{
      background:#0b1220;
      border:1px solid var(--border);
      color:var(--text);
      border-radius:12px;
      padding:12px 10px;
      min-width: 34px;
      font-weight:800;
      cursor:pointer;
      transition: transform .06s ease, background .18s ease, border-color .18s ease;
      text-transform:uppercase;
    }
    button.key:active{ transform: scale(0.98); }
    button.key.wide{ min-width: 74px; font-size:12px; }
    button.key.correct{ background:#16a34a; border-color:#22c55e; color:white; }
    button.key.present{ background:#ca8a04; border-color:#eab308; color:white; }
    button.key.absent{ background:#334155; border-color:#475569; color:#e2e8f0; }

    .status{
      margin-top:14px;
      background: rgba(15,23,42,0.7);
      border:1px solid var(--border2);
      border-radius:14px;
      padding:12px 12px;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .msg{color:var(--muted); font-size:13px; line-height:1.35;}
    .msg strong{ color: var(--text); }
    .actions{display:flex; gap:8px; flex-wrap:wrap;}
    .actions button{
      background:#0b1220;
      border:1px solid var(--border);
      color:var(--text);
      border-radius:12px;
      padding:10px 10px;
      cursor:pointer;
      font-weight:800;
      font-size:12px;
      white-space:nowrap;
    }
    .actions button.hintBtn{
      border-color: rgba(56,189,248,0.45);
    }

    .hint{font-size:12px; color:var(--muted); margin-top:10px; text-align:center;}
    .shake{ animation: shake .25s linear; }
    @keyframes shake{
      0%,100%{ transform: translateX(0); }
      25%{ transform: translateX(-6px); }
      75%{ transform: translateX(6px); }
    }

    /* Overlay (progress + recap) */
    .overlay{
      position:fixed;
      inset:0;
      background: rgba(2,6,23,0.72);
      backdrop-filter: blur(8px);
      display:none;
      align-items:center;
      justify-content:center;
      padding:24px;
      z-index:50;
    }
    .modal{
      width:min(760px, 100%);
      background: rgba(17,24,39,0.92);
      border:1px solid rgba(148,163,184,0.28);
      border-radius:18px;
      padding:18px;
      box-shadow: 0 18px 70px rgba(0,0,0,0.6);
    }
    .modal h2{
      margin:0 0 6px 0;
      font-size:16px;
      letter-spacing:0.4px;
    }
    .modal .meta{
      color:var(--muted);
      font-size:12px;
      margin-bottom:12px;
    }
    .card{
      border:1px solid var(--border2);
      background: rgba(15,23,42,0.55);
      border-radius:14px;
      padding:12px;
      margin:10px 0;
    }
    .definition{
      font-size:13px;
      color:var(--text);
      line-height:1.4;
    }
    .emoji{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      white-space: pre;
      font-size:14px;
      line-height:1.25;
      color: var(--text);
    }
    .modal .btnrow{
      display:flex;
      gap:8px;
      justify-content:flex-end;
      flex-wrap:wrap;
      margin-top:12px;
    }
    .modal button{
      background:#0b1220;
      border:1px solid var(--border);
      color:var(--text);
      border-radius:12px;
      padding:10px 12px;
      cursor:pointer;
      font-weight:800;
      font-size:12px;
    }
    .modal button.primary{
      border-color: rgba(34,197,94,0.6);
    }
    .smallpill{
      display:inline-block;
      padding:4px 8px;
      border:1px solid var(--border);
      border-radius:999px;
      font-size:11px;
      color:var(--muted);
      margin-left:8px;
      vertical-align:middle;
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Wordle Sequence">
    <header>
      <div>
        <h1>WORDLE</h1>
        <div class="sub" id="subtitle">3 rounds ¬∑ learn the words</div>
      </div>
      <div class="pill" id="roundPill">Round 1 / 3</div>
    </header>

    <main id="grid" aria-label="Game grid"></main>

    <div class="keyboard" aria-label="Keyboard">
      <div class="kb-row" id="row1"></div>
      <div class="kb-row" id="row2"></div>
      <div class="kb-row" id="row3"></div>
    </div>

    <div class="status">
      <div class="msg" id="message">Type your guess, then press <strong>Enter</strong>.</div>
      <div class="actions">
        <button class="hintBtn" id="hintBtn" title="Reveal a correct-position letter (locked)">HINT</button>
        <button id="copyBtn" title="Copy share result for this round">COPY ROUND</button>
        <button id="copyAllBtn" title="Copy all rounds (when finished)">COPY ALL</button>
        <button id="resetBtn" title="Restart current word">RESET</button>
      </div>
    </div>

    <div class="hint" id="hintLine">Hints vary by round.</div>
  </div>

  <div class="overlay" id="overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-label="Progress">
      <div id="modalContent"></div>
      <div class="btnrow" id="modalButtons"></div>
    </div>
  </div>

<script>
(() => {
  const ROUNDS = [
    {
      answer: "JHOLI",
      definition: "Jholi - Refers to the cloth bag that sadhus used to carry in old times to ask for donations."
    },
    {
      answer: "PRAYAGRAJ",
      definition: "Prayagraj ‚Äì One of the oldest citiies in India, where three holy rivers of India meet ‚Äì Ganga, Yamuna, nad Saraswati"
    },
    {
      answer: "DAN",
      definition: "Dan ‚Äì Donation"
    }
  ];

  const MAX_ROWS = 6;

  // Hints per round: JHOLI=1, PRAYAGRAJ=5, DAN=1
  const HINTS_BY_ROUND = [1, 5, 1];

  // Allow ANY letters-only guess
  function isValidWord(w) {
    return /^[A-Z]+$/.test(w);
  }

  const gridEl = document.getElementById("grid");
  const msgEl = document.getElementById("message");
  const hintBtn = document.getElementById("hintBtn");
  const hintLine = document.getElementById("hintLine");
  const copyBtn = document.getElementById("copyBtn");
  const copyAllBtn = document.getElementById("copyAllBtn");
  const resetBtn = document.getElementById("resetBtn");
  const roundPill = document.getElementById("roundPill");
  const subtitle = document.getElementById("subtitle");

  const overlay = document.getElementById("overlay");
  const modalContent = document.getElementById("modalContent");
  const modalButtons = document.getElementById("modalButtons");

  const layout = ["QWERTYUIOP", "ASDFGHJKL", "ZXCVBNM"];
  const keyEls = new Map();
  const r1 = document.getElementById("row1");
  const r2 = document.getElementById("row2");
  const r3 = document.getElementById("row3");

  function clearEl(el){ while(el.firstChild) el.removeChild(el.firstChild); }

  function addKey(container, label, wide=false) {
    const b = document.createElement("button");
    b.className = "key" + (wide ? " wide" : "");
    b.textContent = label;
    b.addEventListener("click", () => handleKey(label));
    container.appendChild(b);
    keyEls.set(label, b);
  }

  function buildKeyboard(){
    clearEl(r1); clearEl(r2); clearEl(r3);
    keyEls.clear();
    for (const ch of layout[0]) addKey(r1, ch);
    for (const ch of layout[1]) addKey(r2, ch);
    addKey(r3, "Enter", true);
    for (const ch of layout[2]) addKey(r3, ch);
    addKey(r3, "‚å´", true);
  }

  let roundIndex = 0;
  let ANSWER = "";
  let WORD_LEN = 0;

  let tiles = [];
  let row = 0, col = 0;
  let guesses = [];
  let done = false;

  let hintsUsed = 0;
  let fixedPositions = new Map(); // pos -> letter

  const roundResults = ROUNDS.map(() => ({
    finished:false, won:false, attempts:0, emoji:"", answer:"", definition:""
  }));

  function hintsAllowedThisRound() {
    return HINTS_BY_ROUND[roundIndex] ?? 1;
  }

  function setMessage(html) { msgEl.innerHTML = html; }

  function popTile(r,c){
    const t = tiles[r][c];
    t.classList.remove("pop");
    void t.offsetWidth;
    t.classList.add("pop");
  }

  function shakeRow(r){
    const rowEl = gridEl.children[r];
    rowEl.classList.remove("shake");
    void rowEl.offsetWidth;
    rowEl.classList.add("shake");
  }

  function buildGrid() {
    clearEl(gridEl);
    tiles = [];
    for (let r = 0; r < MAX_ROWS; r++) {
      const rowEl = document.createElement("div");
      rowEl.className = "row";
      rowEl.style.gridTemplateColumns = `repeat(${WORD_LEN}, 1fr)`;
      const rowTiles = [];
      for (let c = 0; c < WORD_LEN; c++) {
        const t = document.createElement("div");
        t.className = "tile";
        rowEl.appendChild(t);
        rowTiles.push(t);
      }
      gridEl.appendChild(rowEl);
      tiles.push(rowTiles);
    }
  }

  function firstEditableCol(start=0) {
    for (let c = start; c < WORD_LEN; c++) {
      if (!fixedPositions.has(c)) return c;
    }
    return WORD_LEN;
  }

  function lastEditableCol(start) {
    for (let c = start; c >= 0; c--) {
      if (!fixedPositions.has(c)) return c;
    }
    return -1;
  }

  function render() {
    for (let r=0; r<MAX_ROWS; r++){
      for (let c=0; c<WORD_LEN; c++){
        tiles[r][c].textContent = guesses[r][c];
      }
    }
  }

  function initStateForRound(i) {
    roundIndex = i;
    ANSWER = ROUNDS[i].answer.toUpperCase().replace(/[^A-Z]/g, "");
    WORD_LEN = ANSWER.length;

    row = 0;
    col = 0;
    done = false;

    hintsUsed = 0;
    fixedPositions = new Map();

    guesses = Array.from({length: MAX_ROWS}, () => Array(WORD_LEN).fill(""));

    roundPill.textContent = `Round ${i+1} / ${ROUNDS.length}`;
    subtitle.textContent = `${WORD_LEN} letters ¬∑ ${MAX_ROWS} tries`;
    hintLine.textContent = `Hints this round: ${hintsAllowedThisRound()} (reveals a correct-position letter and locks it).`;

    buildGrid();
    buildKeyboard();
    render();

    col = firstEditableCol(0);
    setMessage(`Type a <strong>${WORD_LEN}-letter</strong> guess, then press <strong>Enter</strong>.`);
    updateHintButton();
  }

  function scoreGuess(guess, answer) {
    const res = Array(WORD_LEN).fill("absent");
    const a = answer.split("");
    const g = guess.split("");

    for (let i=0;i<WORD_LEN;i++){
      if (g[i] === a[i]) { res[i]="correct"; a[i]=null; g[i]=null; }
    }
    for (let i=0;i<WORD_LEN;i++){
      if (!g[i]) continue;
      const idx = a.indexOf(g[i]);
      if (idx !== -1) { res[i]="present"; a[idx]=null; }
    }
    return res;
  }

  function updateKeyboard(guess, score) {
    for (let i=0;i<WORD_LEN;i++){
      const ch = guess[i];
      const key = keyEls.get(ch);
      if (!key) continue;

      const cur = key.classList.contains("correct") ? "correct"
                : key.classList.contains("present") ? "present"
                : key.classList.contains("absent") ? "absent"
                : null;

      const next = score[i];
      const rank = {correct:3, present:2, absent:1, null:0};
      if (rank[next] > rank[cur ?? "null"]) {
        key.classList.remove("correct","present","absent");
        key.classList.add(next);
      }
    }
  }

  function buildEmojiForCurrentRound() {
    let out = [];
    const playedRows = Math.min(row + 1, MAX_ROWS);
    for (let r=0; r<playedRows; r++){
      const g = guesses[r].join("");
      if (g.length !== WORD_LEN) break;
      const s = scoreGuess(g, ANSWER);
      out.push(s.map(x => x==="correct"?"üü©":x==="present"?"üü®":"‚¨õ").join(""));
      if (g === ANSWER) break;
    }
    return out.join("\n");
  }

  function openModal(html, buttons) {
    modalContent.innerHTML = html;
    clearEl(modalButtons);
    for (const b of buttons) {
      const btn = document.createElement("button");
      btn.textContent = b.label;
      if (b.primary) btn.classList.add("primary");
      btn.addEventListener("click", b.onClick);
      modalButtons.appendChild(btn);
    }
    overlay.style.display = "flex";
    overlay.setAttribute("aria-hidden","false");
  }
  function closeModal() {
    overlay.style.display = "none";
    overlay.setAttribute("aria-hidden","true");
  }

  function showProgressModal({won}) {
    const def = ROUNDS[roundIndex].definition;
    const emoji = buildEmojiForCurrentRound();

    roundResults[roundIndex] = {
      finished:true,
      won,
      attempts: (won ? row+1 : MAX_ROWS),
      emoji,
      answer: ANSWER,
      definition: def
    };

    const title = won ? "‚úÖ Nice!" : "‚ùå Out of tries";
    const attemptsLabel = won ? `Solved in ${row+1}/${MAX_ROWS}` : `Answer: ${ANSWER}`;

    const html = `
      <h2>${title} <span class="smallpill">Round ${roundIndex+1} / ${ROUNDS.length}</span></h2>
      <div class="meta">${attemptsLabel}</div>
      <div class="card"><div class="definition">${def}</div></div>
      <div class="card">
        <div class="meta" style="margin-bottom:8px;">Your grid</div>
        <div class="emoji">${emoji || ""}</div>
      </div>
    `;

    const buttons = [
      {
        label: "Copy Round",
        onClick: async () => {
          try {
            await navigator.clipboard.writeText(`Wordle Round ${roundIndex+1}/${ROUNDS.length} (${ANSWER})\n${emoji}`);
            setMessage("Copied round result.");
          } catch {
            setMessage("Couldn‚Äôt copy.");
          }
        }
      }
    ];

    if (roundIndex < ROUNDS.length - 1) {
      buttons.push({
        label: "Next ‚Üí",
        primary: true,
        onClick: () => {
          closeModal();
          initStateForRound(roundIndex + 1);
        }
      });
    } else {
      buttons.push({
        label: "Finish ‚Üí Recap",
        primary: true,
        onClick: () => {
          closeModal();
          showFinalRecap();
        }
      });
    }

    openModal(html, buttons);
  }

  function buildAllShareText() {
    const parts = [];
    parts.push(`Wordle Sequence (${ROUNDS.length} rounds)`);
    for (let i=0;i<ROUNDS.length;i++){
      const r = roundResults[i];
      const ans = r.answer || ROUNDS[i].answer.toUpperCase();
      const emoji = (r.emoji || "").trim();
      const status = r.finished ? (r.won ? `${r.attempts}/6` : `X/6`) : "‚Äî";
      parts.push(`\nRound ${i+1}: ${ans}  ${status}`);
      if (emoji) parts.push(emoji);
    }
    parts.push("\n");
    return parts.join("\n");
  }

  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;");
  }

  function showFinalRecap() {
    const blocks = roundResults.map((r, i) => {
      const ans = r.answer || ROUNDS[i].answer.toUpperCase();
      const status = r.finished ? (r.won ? `Solved in ${r.attempts}/6` : `Not solved (Answer: ${ans})`) : "Not played";
      return `
        <div class="card">
          <div class="meta"><strong>Round ${i+1}:</strong> ${ans} ¬∑ ${status}</div>
          <div class="definition">${r.definition || ROUNDS[i].definition}</div>
          <div style="height:10px;"></div>
          <div class="emoji">${(r.emoji || "").trim()}</div>
        </div>
      `;
    }).join("");

    const fullShare = buildAllShareText();
    const html = `
      <h2>üéâ Recap <span class="smallpill">All 3 rounds</span></h2>
      <div class="meta">Here are all words + definitions + your results.</div>
      ${blocks}
      <div class="card">
        <div class="meta" style="margin-bottom:8px;">Copy-all text</div>
        <div class="emoji">${escapeHtml(fullShare)}</div>
      </div>
    `;

    openModal(html, [
      {
        label: "Copy All",
        primary: true,
        onClick: async () => {
          try {
            await navigator.clipboard.writeText(fullShare);
            setMessage("Copied all rounds.");
          } catch {
            setMessage("Couldn‚Äôt copy.");
          }
        }
      },
      {
        label: "Play Again",
        onClick: () => {
          closeModal();
          for (let i=0;i<roundResults.length;i++){
            roundResults[i] = {finished:false, won:false, attempts:0, emoji:"", answer:"", definition:""};
          }
          initStateForRound(0);
        }
      }
    ]);
  }

  function updateHintButton() {
    const remaining = Math.max(0, hintsAllowedThisRound() - hintsUsed);
    hintBtn.textContent = `HINT (${remaining})`;
    hintBtn.disabled = done || remaining <= 0 || fixedPositions.size >= WORD_LEN;
    hintBtn.style.opacity = hintBtn.disabled ? "0.6" : "1";
  }

  function revealHint() {
    if (done) return;
    if (hintsUsed >= hintsAllowedThisRound()) return;

    const candidates = [];
    for (let i=0;i<WORD_LEN;i++){
      if (!fixedPositions.has(i)) candidates.push(i);
    }
    if (candidates.length === 0) return;

    const pos = candidates[Math.floor(Math.random() * candidates.length)];
    const letter = ANSWER[pos];
    fixedPositions.set(pos, letter);
    hintsUsed++;

    for (let r=0; r<MAX_ROWS; r++) {
      guesses[r][pos] = letter;
    }
    for (let r=0; r<MAX_ROWS; r++) {
      tiles[r][pos].classList.add("hinted");
    }

    render();
    col = firstEditableCol(0);
    setMessage(`üí° Hint revealed: position <strong>${pos+1}</strong> is <strong>${letter}</strong> (locked).`);
    updateHintButton();
  }

  function lockInGuess() {
    const guess = guesses[row].join("");

    if (guesses[row].some(ch => ch === "")) {
      setMessage(`Fill all <strong>${WORD_LEN}</strong> letters.`);
      shakeRow(row);
      return;
    }

    if (!isValidWord(guess)) {
      setMessage("Letters only (A‚ÄìZ).");
      shakeRow(row);
      return;
    }

    const score = scoreGuess(guess, ANSWER);
    for (let c=0; c<WORD_LEN; c++){
      tiles[row][c].classList.add(score[c]);
    }
    updateKeyboard(guess, score);

    if (guess === ANSWER) {
      done = true;
      setMessage("‚úÖ Correct! (See progress screen)");
      updateHintButton();
      showProgressModal({won:true});
      return;
    }

    row++;
    col = firstEditableCol(0);

    if (row >= MAX_ROWS) {
      done = true;
      setMessage(`‚ùå Out of tries. (See progress screen)`);
      updateHintButton();
      showProgressModal({won:false});
      return;
    }

    setMessage("Keep going.");
  }

  function handleKey(k) {
    if (done) return;

    if (k === "Enter") { lockInGuess(); return; }

    if (k === "‚å´" || k === "Backspace") {
      let prev = lastEditableCol(col - 1);
      if (prev === -1) return;
      col = prev;
      guesses[row][col] = "";
      render();
      return;
    }

    if (/^[A-Z]$/.test(k)) {
      let c = col;
      while (c < WORD_LEN && fixedPositions.has(c)) c++;
      if (c >= WORD_LEN) return;

      guesses[row][c] = k;
      popTile(row, c);
      render();

      col = firstEditableCol(c + 1);
    }
  }

  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape" && overlay.style.display === "flex") {
      closeModal();
      return;
    }
    if (overlay.style.display === "flex") return;

    if (done) return;
    if (e.key === "Enter") return handleKey("Enter");
    if (e.key === "Backspace") return handleKey("Backspace");
    const up = e.key.toUpperCase();
    if (/^[A-Z]$/.test(up)) handleKey(up);
  });

  hintBtn.addEventListener("click", () => revealHint());

  copyBtn.addEventListener("click", async () => {
    try {
      const emoji = done ? buildEmojiForCurrentRound() : "(finish the round to get the grid)";
      const text = `Wordle Round ${roundIndex+1}/${ROUNDS.length} (${ANSWER})\n${emoji}`;
      await navigator.clipboard.writeText(text);
      setMessage("Copied round result.");
    } catch {
      setMessage("Couldn‚Äôt copy.");
    }
  });

  copyAllBtn.addEventListener("click", async () => {
    try {
      await navigator.clipboard.writeText(buildAllShareText());
      setMessage("Copied all rounds.");
    } catch {
      setMessage("Couldn‚Äôt copy.");
    }
  });

  resetBtn.addEventListener("click", () => initStateForRound(roundIndex));

  buildKeyboard();
  initStateForRound(0);
})();
</script>
</body>
</html>
