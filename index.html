<script>
(() => {
  // Rounds
  const ROUNDS = [
    { answer: "JHOLI", definition: "Jholi - Refers to the cloth bag that sadhus used to carry in old times to ask for donations." },
    { answer: "PRAYAGRAJ", definition: "Prayagraj ‚Äì One of the oldest citiies in India, where three holy rivers of India meet ‚Äì Ganga, Yamuna, nad Saraswati" },
    { answer: "DAN", definition: "Dan ‚Äì Donation" }
  ];

  const MAX_ROWS = 6;

  // Hints per round: JHOLI=1, PRAYAGRAJ=5, DAN=1
  const HINTS_BY_ROUND = [1, 5, 1];

  // Allow ANY letters-only guess
  function isValidWord(w) { return /^[A-Z]+$/.test(w); }

  // UI
  const gameCard = document.getElementById("gameCard");
  const ghostInput = document.getElementById("ghostInput");
  const gridEl = document.getElementById("grid");
  const msgEl = document.getElementById("message");
  const hintBtn = document.getElementById("hintBtn");
  const copyBtn = document.getElementById("copyBtn");
  const copyAllBtn = document.getElementById("copyAllBtn");
  const resetBtn = document.getElementById("resetBtn");
  const roundPill = document.getElementById("roundPill");
  const subtitle = document.getElementById("subtitle");

  const overlay = document.getElementById("overlay");
  const modalContent = document.getElementById("modalContent");
  const modalButtons = document.getElementById("modalButtons");

  // On-screen keyboard containers
  const kb1 = document.getElementById("kb1");
  const kb2 = document.getElementById("kb2");
  const kb3 = document.getElementById("kb3");

  function clearEl(el){ while(el.firstChild) el.removeChild(el.firstChild); }

  // Game state
  let roundIndex = 0;
  let ANSWER = "";
  let WORD_LEN = 0;

  let tiles = [];
  let row = 0, col = 0;
  let guesses = [];
  let done = false;

  let hintsUsed = 0;
  let fixedPositions = new Map(); // pos -> letter

  const roundResults = ROUNDS.map(() => ({
    finished:false, won:false, attempts:0, emoji:"", answer:"", definition:""
  }));

  function hintsAllowedThisRound() {
    return HINTS_BY_ROUND[roundIndex] ?? 1;
  }

  function setMessage(html){ msgEl.innerHTML = html; }

  function popTile(r,c){
    const t = tiles[r][c];
    t.classList.remove("pop");
    void t.offsetWidth;
    t.classList.add("pop");
  }

  function shakeRow(r){
    const rowEl = gridEl.children[r];
    rowEl.classList.remove("shake");
    void rowEl.offsetWidth;
    rowEl.classList.add("shake");
  }

  function buildGrid(){
    clearEl(gridEl);
    tiles = [];
    for (let r=0;r<MAX_ROWS;r++){
      const rowEl = document.createElement("div");
      rowEl.className = "row";
      rowEl.style.gridTemplateColumns = `repeat(${WORD_LEN}, 1fr)`;
      const rowTiles = [];
      for (let c=0;c<WORD_LEN;c++){
        const t = document.createElement("div");
        t.className = "tile";
        rowEl.appendChild(t);
        rowTiles.push(t);
      }
      gridEl.appendChild(rowEl);
      tiles.push(rowTiles);
    }
  }

  function render(){
    for (let r=0;r<MAX_ROWS;r++){
      for (let c=0;c<WORD_LEN;c++){
        tiles[r][c].textContent = guesses[r][c];
      }
    }
  }

  function firstEditableCol(start=0){
    for (let c=start;c<WORD_LEN;c++){
      if (!fixedPositions.has(c)) return c;
    }
    return WORD_LEN;
  }

  function lastEditableCol(start){
    for (let c=start;c>=0;c--){
      if (!fixedPositions.has(c)) return c;
    }
    return -1;
  }

  function initStateForRound(i){
    roundIndex = i;
    ANSWER = ROUNDS[i].answer.toUpperCase().replace(/[^A-Z]/g, "");
    WORD_LEN = ANSWER.length;

    row = 0; col = 0; done = false;
    hintsUsed = 0;
    fixedPositions = new Map();

    guesses = Array.from({length: MAX_ROWS}, () => Array(WORD_LEN).fill(""));

    roundPill.textContent = `Round ${i+1} / ${ROUNDS.length}`;
    subtitle.textContent = `${WORD_LEN} letters ‚Ä¢ Hints: ${hintsAllowedThisRound()}`;

    buildGrid();
    render();
    buildKeyboard();

    col = firstEditableCol(0);
    setMessage(`Type a <strong>${WORD_LEN}-letter</strong> guess, then press <strong>Enter</strong>.`);
    updateHintButton();
    focusInput();
  }

  function scoreGuess(guess, answer){
    const res = Array(WORD_LEN).fill("absent");
    const a = answer.split("");
    const g = guess.split("");

    for (let i=0;i<WORD_LEN;i++){
      if (g[i] === a[i]) { res[i]="correct"; a[i]=null; g[i]=null; }
    }
    for (let i=0;i<WORD_LEN;i++){
      if (!g[i]) continue;
      const idx = a.indexOf(g[i]);
      if (idx !== -1) { res[i]="present"; a[idx]=null; }
    }
    return res;
  }

  function buildEmojiForCurrentRound(){
    let out = [];
    const playedRows = Math.min(row + 1, MAX_ROWS);
    for (let r=0;r<playedRows;r++){
      const g = guesses[r].join("");
      if (g.length !== WORD_LEN) break;
      const s = scoreGuess(g, ANSWER);
      out.push(s.map(x => x==="correct"?"üü©":x==="present"?"üü®":"‚¨õ").join(""));
      if (g === ANSWER) break;
    }
    return out.join("\n");
  }

  function openModal(html, buttons){
    modalContent.innerHTML = html;
    clearEl(modalButtons);
    for (const b of buttons){
      const btn = document.createElement("button");
      btn.textContent = b.label;
      if (b.primary) btn.classList.add("primary");
      btn.addEventListener("click", b.onClick);
      modalButtons.appendChild(btn);
    }
    overlay.style.display = "flex";
    overlay.setAttribute("aria-hidden","false");
  }

  function closeModal(){
    overlay.style.display = "none";
    overlay.setAttribute("aria-hidden","true");
  }

  function showProgressModal({won}){
    const def = ROUNDS[roundIndex].definition;
    const emoji = buildEmojiForCurrentRound();

    roundResults[roundIndex] = {
      finished:true,
      won,
      attempts: (won ? row+1 : MAX_ROWS),
      emoji,
      answer: ANSWER,
      definition: def
    };

    const title = won ? "‚úÖ Nice!" : "‚ùå Out of tries";
    const attemptsLabel = won ? `Solved in ${row+1}/${MAX_ROWS}` : `Answer: ${ANSWER}`;

    const html = `
      <h2>${title}</h2>
      <div class="meta">${attemptsLabel}</div>
      <div class="cardbox"><div class="definition">${def}</div></div>
      <div class="cardbox">
        <div class="meta" style="margin-bottom:8px;">Your grid</div>
        <div class="emoji">${emoji || ""}</div>
      </div>
    `;

    const buttons = [
      {
        label: "Copy Round",
        onClick: async () => {
          try {
            await navigator.clipboard.writeText(`Wordle Round ${roundIndex+1}/${ROUNDS.length} (${ANSWER})\n${emoji}`);
            setMessage("Copied round result.");
          } catch {
            setMessage("Couldn‚Äôt copy.");
          }
        }
      }
    ];

    if (roundIndex < ROUNDS.length - 1) {
      buttons.push({
        label: "Next ‚Üí",
        primary: true,
        onClick: () => {
          closeModal();
          initStateForRound(roundIndex + 1);
        }
      });
    } else {
      buttons.push({
        label: "Finish ‚Üí Recap",
        primary: true,
        onClick: () => {
          closeModal();
          showFinalRecap();
        }
      });
    }

    openModal(html, buttons);
  }

  function buildAllShareText(){
    const parts = [];
    parts.push(`Wordle Sequence (${ROUNDS.length} rounds)`);
    for (let i=0;i<ROUNDS.length;i++){
      const r = roundResults[i];
      const ans = r.answer || ROUNDS[i].answer.toUpperCase();
      const emoji = (r.emoji || "").trim();
      const status = r.finished ? (r.won ? `${r.attempts}/6` : `X/6`) : "‚Äî";
      parts.push(`\nRound ${i+1}: ${ans}  ${status}`);
      if (emoji) parts.push(emoji);
    }
    parts.push("\n");
    return parts.join("\n");
  }

  function escapeHtml(s){
    return String(s).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
  }

  function showFinalRecap(){
    const blocks = roundResults.map((r, i) => {
      const ans = r.answer || ROUNDS[i].answer.toUpperCase();
      const status = r.finished ? (r.won ? `Solved in ${r.attempts}/6` : `Not solved (Answer: ${ans})`) : "Not played";
      return `
        <div class="cardbox">
          <div class="meta"><strong>Round ${i+1}:</strong> ${ans} ¬∑ ${status}</div>
          <div class="definition">${r.definition || ROUNDS[i].definition}</div>
          <div style="height:10px;"></div>
          <div class="emoji">${(r.emoji || "").trim()}</div>
        </div>
      `;
    }).join("");

    const fullShare = buildAllShareText();
    const html = `
      <h2>üéâ Recap</h2>
      <div class="meta">All words + definitions + your results.</div>
      ${blocks}
      <div class="cardbox">
        <div class="meta" style="margin-bottom:8px;">Copy-all text</div>
        <div class="emoji">${escapeHtml(fullShare)}</div>
      </div>
    `;

    openModal(html, [
      {
        label: "Copy All",
        primary: true,
        onClick: async () => {
          try {
            await navigator.clipboard.writeText(fullShare);
            setMessage("Copied all rounds.");
          } catch {
            setMessage("Couldn‚Äôt copy.");
          }
        }
      },
      {
        label: "Play Again",
        onClick: () => {
          closeModal();
          for (let i=0;i<roundResults.length;i++){
            roundResults[i] = {finished:false, won:false, attempts:0, emoji:"", answer:"", definition:""};
          }
          initStateForRound(0);
        }
      }
    ]);
  }

  // Hints
  function updateHintButton(){
    const remaining = Math.max(0, hintsAllowedThisRound() - hintsUsed);
    hintBtn.textContent = `HINT (${remaining})`;
    hintBtn.disabled = done || remaining <= 0 || fixedPositions.size >= WORD_LEN;
  }

  function revealHint(){
    if (done) return;
    if (hintsUsed >= hintsAllowedThisRound()) return;

    const candidates = [];
    for (let i=0;i<WORD_LEN;i++){
      if (!fixedPositions.has(i)) candidates.push(i);
    }
    if (!candidates.length) return;

    const pos = candidates[Math.floor(Math.random() * candidates.length)];
    const letter = ANSWER[pos];
    fixedPositions.set(pos, letter);
    hintsUsed++;

    for (let r=0;r<MAX_ROWS;r++){
      guesses[r][pos] = letter;
      tiles[r][pos].classList.add("hinted");
    }
    render();

    col = firstEditableCol(0);
    setMessage(`üí° Hint: position <strong>${pos+1}</strong> is <strong>${letter}</strong> (locked).`);
    updateHintButton();
    focusInput();
  }

  // Gameplay
  function lockInGuess(){
    if (guesses[row].some(ch => ch === "")) {
      setMessage(`Fill all <strong>${WORD_LEN}</strong> letters.`);
      shakeRow(row);
      return;
    }

    const guess = guesses[row].join("");
    if (!isValidWord(guess)) {
      setMessage("Letters only (A‚ÄìZ).");
      shakeRow(row);
      return;
    }

    const score = scoreGuess(guess, ANSWER);
    for (let c=0;c<WORD_LEN;c++){
      tiles[row][c].classList.add(score[c]);
    }

    if (guess === ANSWER) {
      done = true;
      setMessage("‚úÖ Correct!");
      updateHintButton();
      showProgressModal({won:true});
      return;
    }

    row++;
    col = firstEditableCol(0);

    if (row >= MAX_ROWS) {
      done = true;
      setMessage(`‚ùå Out of tries.`);
      updateHintButton();
      showProgressModal({won:false});
      return;
    }

    setMessage("Keep going.");
    focusInput();
  }

  function handleBackspace(){
    let prev = lastEditableCol(col - 1);
    if (prev === -1) return;
    col = prev;
    guesses[row][col] = "";
    render();
  }

  function handleLetter(ch){
    let c = col;
    while (c < WORD_LEN && fixedPositions.has(c)) c++;
    if (c >= WORD_LEN) return;

    guesses[row][c] = ch;
    popTile(row, c);
    render();

    col = firstEditableCol(c + 1);
  }

  // Unified handler for physical + on-screen keyboard
  function handleKey(k){
    if (overlay.style.display === "flex") return;
    if (done) return;

    if (k === "Enter") return lockInGuess();
    if (k === "‚å´") return handleBackspace();
    if (/^[A-Z]$/.test(k)) return handleLetter(k);
  }

  function focusInput(){
    try { ghostInput.focus({preventScroll:true}); } catch { ghostInput.focus(); }
  }

  // Desktop keyboard
  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape" && overlay.style.display === "flex") { closeModal(); return; }
    if (overlay.style.display === "flex") return;

    if (e.key === "Enter") { e.preventDefault(); return handleKey("Enter"); }
    if (e.key === "Backspace") { e.preventDefault(); return handleKey("‚å´"); }

    const up = e.key.toUpperCase();
    if (/^[A-Z]$/.test(up)) return handleKey(up);
  });

  // Mobile typing via hidden input
  ghostInput.addEventListener("input", () => {
    if (overlay.style.display === "flex") { ghostInput.value = ""; return; }
    if (done) { ghostInput.value = ""; return; }

    const v = ghostInput.value.toUpperCase().replace(/[^A-Z]/g, "");
    if (!v) { ghostInput.value = ""; return; }

    for (const ch of v) handleKey(ch);
    ghostInput.value = "";
  });

  // Tap the card to bring up mobile keyboard
  gameCard.addEventListener("pointerdown", () => focusInput());

  // On-screen keyboard build
  const KB_LAYOUT = ["QWERTYUIOP","ASDFGHJKL","ZXCVBNM"];
  function addKey(el, label, wide=false){
    const b = document.createElement("button");
    b.className = "key" + (wide ? " wide" : "");
    b.type = "button";
    b.textContent = label;
    b.addEventListener("click", () => {
      focusInput();
      handleKey(label);
    });
    el.appendChild(b);
  }

  function buildKeyboard(){
    kb1.innerHTML = ""; kb2.innerHTML = ""; kb3.innerHTML = "";
    for (const c of KB_LAYOUT[0]) addKey(kb1, c);
    for (const c of KB_LAYOUT[1]) addKey(kb2, c);
    addKey(kb3, "Enter", true);
    for (const c of KB_LAYOUT[2]) addKey(kb3, c);
    addKey(kb3, "‚å´", true);
  }

  // Buttons
  hintBtn.addEventListener("click", () => { focusInput(); revealHint(); });
  copyBtn.addEventListener("click", async () => {
    try {
      const emoji = done ? buildEmojiForCurrentRound() : "(finish the round to get the grid)";
      await navigator.clipboard.writeText(`Wordle Round ${roundIndex+1}/${ROUNDS.length} (${ANSWER})\n${emoji}`);
      setMessage("Copied round result.");
    } catch {
      setMessage("Couldn‚Äôt copy.");
    }
  });
  copyAllBtn.addEventListener("click", async () => {
    try {
      await navigator.clipboard.writeText(buildAllShareText());
      setMessage("Copied all rounds.");
    } catch {
      setMessage("Couldn‚Äôt copy.");
    }
  });
  resetBtn.addEventListener("click", () => initStateForRound(roundIndex));

  // Start
  initStateForRound(0);
})();
</script>
