<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Uttaryan Wordle ‚Äî JHOLI ‚Üí PRAYAGRAJ ‚Üí DAN</title>
  <style>
    :root{
      --sky1:#60A5FA;
      --sky2:#93C5FD;
      --sky3:#FDE68A;
      --glass: rgba(255,255,255,0.16);
      --glass2: rgba(255,255,255,0.10);
      --border: rgba(255,255,255,0.22);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.72);
      --tile: rgba(15,23,42,0.55);
      --tileBorder: rgba(255,255,255,0.18);
      --hint: rgba(56,189,248,0.95);
    }

    *{box-sizing:border-box}

    body{
      margin:0;
      min-height:100vh;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--text);
      overflow-x:hidden;
      background:
        radial-gradient(1100px 700px at 30% 0%, rgba(253,230,138,0.85) 0%, rgba(96,165,250,0.15) 55%, rgba(2,6,23,0.0) 70%),
        linear-gradient(180deg, var(--sky1) 0%, var(--sky2) 48%, var(--sky3) 100%);
    }

    /* Floating kite layer */
    .kitefield{
      position:fixed;
      inset:0;
      pointer-events:none;
      overflow:hidden;
      z-index:0;
    }
    .kite{
      position:absolute;
      width:28px;
      height:28px;
      transform: rotate(45deg);
      border-radius:6px;
      opacity:0.55;
      filter: drop-shadow(0 8px 18px rgba(0,0,0,0.20));
      animation: drift var(--dur) linear infinite;
    }
    .kite::before{
      content:"";
      position:absolute;
      inset:0;
      border-radius:6px;
      background: linear-gradient(135deg, rgba(255,255,255,0.35), rgba(255,255,255,0.08));
      border:1px solid rgba(255,255,255,0.35);
    }
    .kite::after{
      content:"";
      position:absolute;
      width:1px;
      height:90px;
      left:50%;
      top:100%;
      transform: translateX(-50%) rotate(-45deg);
      background: linear-gradient(
        to bottom,
        rgba(255,255,255,0.0),
        rgba(255,255,255,0.28),
        rgba(255,255,255,0.0)
      );
      opacity:0.65;
    }
    @keyframes drift{
      0%   { transform: translate(-20vw, 110vh) rotate(45deg); }
      100% { transform: translate(120vw, -25vh) rotate(45deg); }
    }
    .c1{ background: rgba(34,197,94,0.35); }
    .c2{ background: rgba(250,204,21,0.35); }
    .c3{ background: rgba(244,114,182,0.35); }
    .c4{ background: rgba(251,146,60,0.35); }
    .c5{ background: rgba(56,189,248,0.35); }

    /* Layout */
    .wrap{
      position:relative;
      z-index:1;
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:22px;
    }
    .card{
      width:min(900px, 100%);
      background: linear-gradient(180deg, var(--glass) 0%, var(--glass2) 100%);
      border:1px solid var(--border);
      border-radius:22px;
      padding:18px 18px 16px;
      box-shadow: 0 22px 90px rgba(0,0,0,0.35);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
    }

    .topline{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
      padding:2px 2px 12px;
      border-bottom:1px solid rgba(255,255,255,0.16);
      margin-bottom:10px;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 12px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.22);
      background: rgba(2,6,23,0.18);
      color: var(--text);
      font-weight:900;
      font-size:12px;
      letter-spacing:0.2px;
      user-select:none;
    }
    .small{
      color: var(--muted);
      font-size:12px;
      line-height:1.2;
      user-select:none;
    }

    /* Grid */
    #grid{ margin-top: 6px; }
    .row{
      display:grid;
      gap:10px;
      margin:10px 0;
    }
    .tile{
      aspect-ratio: 1 / 1;
      display:flex;
      align-items:center;
      justify-content:center;
      background: var(--tile);
      border:1px solid var(--tileBorder);
      border-radius:14px;
      font-size:28px;
      font-weight:900;
      text-transform:uppercase;
      user-select:none;
      transition: transform .08s ease, background .18s ease, border-color .18s ease, box-shadow .18s ease;
    }
    .tile.pop{ transform: scale(1.04); }
    .tile.correct{ background: rgba(34,197,94,0.85); border-color: rgba(34,197,94,0.95); color:white; }
    .tile.present{ background: rgba(250,204,21,0.78); border-color: rgba(250,204,21,0.95); color: rgba(2,6,23,0.95); }
    .tile.absent{  background: rgba(30,41,59,0.82); border-color: rgba(148,163,184,0.35); color: rgba(255,255,255,0.90); }
    .tile.hinted{
      border-color: var(--hint);
      box-shadow: 0 0 0 2px rgba(56,189,248,0.18) inset, 0 10px 30px rgba(56,189,248,0.08);
    }

    .status{
      margin-top:12px;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
      padding:12px 12px;
      border-radius:16px;
      background: rgba(2,6,23,0.20);
      border: 1px solid rgba(255,255,255,0.16);
    }
    .msg{
      color: var(--muted);
      font-size:13px;
      line-height:1.35;
      max-width: 560px;
    }
    .msg strong{ color: var(--text); }
    .actions{ display:flex; gap:8px; flex-wrap:wrap; }
    .actions button{
      border-radius:14px;
      padding:10px 12px;
      border: 1px solid rgba(255,255,255,0.22);
      background: rgba(2,6,23,0.18);
      color: var(--text);
      font-weight:900;
      font-size:12px;
      cursor:pointer;
      user-select:none;
    }
    .actions button:active{ transform: scale(0.99); }
    .actions button.hintBtn{
      border-color: rgba(56,189,248,0.55);
      background: linear-gradient(135deg, rgba(56,189,248,0.18), rgba(244,114,182,0.10));
    }
    .actions button:disabled{
      opacity:0.55;
      cursor:not-allowed;
    }

    /* On-screen keyboard */
    .keyboard{
      margin-top:14px;
      display:grid;
      gap:8px;
    }
    .kb-row{
      display:flex;
      justify-content:center;
      gap:6px;
      flex-wrap:nowrap;
    }
    .key{
      padding:12px 10px;
      min-width:34px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.25);
      background: rgba(2,6,23,0.22);
      color: var(--text);
      font-weight:900;
      cursor:pointer;
      user-select:none;
    }
    .key.wide{
      min-width:72px;
      font-size:12px;
    }
    .key:active{ transform: scale(0.97); }
    .key:disabled{ opacity:0.55; cursor:not-allowed; }

    .shake{ animation: shake .25s linear; }
    @keyframes shake{
      0%,100%{ transform: translateX(0); }
      25%{ transform: translateX(-6px); }
      75%{ transform: translateX(6px); }
    }

    /* Modal */
    .overlay{
      position:fixed;
      inset:0;
      background: rgba(2,6,23,0.62);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      display:none;
      align-items:center;
      justify-content:center;
      padding:24px;
      z-index:50;
    }
    .modal{
      width:min(760px, 100%);
      background: rgba(255,255,255,0.12);
      border:1px solid rgba(255,255,255,0.22);
      border-radius:20px;
      padding:16px;
      box-shadow: 0 18px 70px rgba(0,0,0,0.55);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
    }
    .modal h2{
      margin:0 0 8px 0;
      font-size:16px;
      letter-spacing:0.2px;
      color: var(--text);
    }
    .modal .meta{
      color: var(--muted);
      font-size:12px;
      margin-bottom:10px;
    }
    .cardbox{
      border:1px solid rgba(255,255,255,0.18);
      background: rgba(2,6,23,0.16);
      border-radius:14px;
      padding:12px;
      margin:10px 0;
    }
    .definition{
      font-size:13px;
      color: var(--text);
      line-height:1.4;
    }
    .emoji{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      white-space: pre;
      font-size:14px;
      line-height:1.25;
      color: var(--text);
    }
    .btnrow{
      display:flex;
      gap:8px;
      justify-content:flex-end;
      flex-wrap:wrap;
      margin-top:12px;
    }
    .btnrow button{
      border-radius:14px;
      padding:10px 12px;
      border: 1px solid rgba(255,255,255,0.22);
      background: rgba(2,6,23,0.18);
      color: var(--text);
      font-weight:900;
      font-size:12px;
      cursor:pointer;
    }
    .btnrow button.primary{
      border-color: rgba(34,197,94,0.65);
      background: linear-gradient(135deg, rgba(34,197,94,0.18), rgba(250,204,21,0.10));
    }

    /* Hidden input: enables mobile keyboard without taking space */
    #ghostInput{
      position:absolute;
      left:-9999px;
      top:-9999px;
      width:1px;
      height:1px;
      opacity:0;
    }
  </style>
</head>
<body>
  <div class="kitefield" aria-hidden="true">
    <div class="kite c1" style="--dur:46s; left:-10vw; top:70vh; width:22px; height:22px; opacity:.42;"></div>
    <div class="kite c2" style="--dur:52s; left:-18vw; top:90vh; width:26px; height:26px; opacity:.48;"></div>
    <div class="kite c3" style="--dur:58s; left:-26vw; top:110vh; width:18px; height:18px; opacity:.40;"></div>
    <div class="kite c4" style="--dur:64s; left:-34vw; top:100vh; width:28px; height:28px; opacity:.45;"></div>
    <div class="kite c5" style="--dur:72s; left:-42vw; top:120vh; width:20px; height:20px; opacity:.38;"></div>

    <div class="kite c2" style="--dur:60s; left:-14vw; top:105vh; width:16px; height:16px; opacity:.32;"></div>
    <div class="kite c4" style="--dur:78s; left:-22vw; top:130vh; width:24px; height:24px; opacity:.34;"></div>
    <div class="kite c1" style="--dur:86s; left:-30vw; top:145vh; width:19px; height:19px; opacity:.30;"></div>
  </div>

  <div class="wrap">
    <div class="card" id="gameCard" role="application" aria-label="Uttaryan Wordle">
      <div class="topline">
        <div class="pill" id="roundPill">Round 1 / 3</div>
        <div class="small" id="subtitle">Tap card to type ‚Ä¢ or use keyboard below</div>
      </div>

      <main id="grid" aria-label="Game grid"></main>

      <div class="status">
        <div class="msg" id="message">Type your guess, then press <strong>Enter</strong>.</div>
        <div class="actions">
          <button class="hintBtn" id="hintBtn" title="Reveal a correct-position letter (locked)">HINT</button>
          <button id="copyBtn" title="Copy share result for this round">COPY ROUND</button>
          <button id="copyAllBtn" title="Copy all rounds (when finished)">COPY ALL</button>
          <button id="resetBtn" title="Restart current word">RESET</button>
        </div>
      </div>

      <!-- On-screen keyboard -->
      <div class="keyboard" aria-label="Keyboard">
        <div class="kb-row" id="kb1"></div>
        <div class="kb-row" id="kb2"></div>
        <div class="kb-row" id="kb3"></div>
      </div>

      <input id="ghostInput" inputmode="text" autocomplete="off" autocapitalize="characters" spellcheck="false" />
    </div>
  </div>

  <div class="overlay" id="overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-label="Progress">
      <div id="modalContent"></div>
      <div class="btnrow" id="modalButtons"></div>
    </div>
  </div>

<script>
(() => {
  // Rounds
  const ROUNDS = [
    { answer: "JHOLI", definition: "Jholi - Refers to the cloth bag that sadhus used to carry in old times to ask for donations." },
    { answer: "PRAYAGRAJ", definition: "Prayagraj ‚Äì One of the oldest citiies in India, where three holy rivers of India meet ‚Äì Ganga, Yamuna, nad Saraswati" },
    { answer: "DAN", definition: "Dan ‚Äì Donation" }
  ];

  const MAX_ROWS = 6;

  // Hints per round: JHOLI=1, PRAYAGRAJ=5, DAN=1
  const HINTS_BY_ROUND = [1, 5, 1];

  // Allow ANY letters-only guess
  function isValidWord(w) { return /^[A-Z]+$/.test(w); }

  // UI
  const gameCard = document.getElementById("gameCard");
  const ghostInput = document.getElementById("ghostInput");
  const gridEl = document.getElementById("grid");
  const msgEl = document.getElementById("message");
  const hintBtn = document.getElementById("hintBtn");
  const copyBtn = document.getElementById("copyBtn");
  const copyAllBtn = document.getElementById("copyAllBtn");
  const resetBtn = document.getElementById("resetBtn");
  const roundPill = document.getElementById("roundPill");
  const subtitle = document.getElementById("subtitle");

  const overlay = document.getElementById("overlay");
  const modalContent = document.getElementById("modalContent");
  const modalButtons = document.getElementById("modalButtons");

  // On-screen keyboard containers
  const kb1 = document.getElementById("kb1");
  const kb2 = document.getElementById("kb2");
  const kb3 = document.getElementById("kb3");

  function clearEl(el){ while(el.firstChild) el.removeChild(el.firstChild); }

  // Game state
  let roundIndex = 0;
  let ANSWER = "";
  let WORD_LEN = 0;

  let tiles = [];
  let row = 0, col = 0;
  let guesses = [];
  let done = false;

  let hintsUsed = 0;
  let fixedPositions = new Map(); // pos -> letter

  const roundResults = ROUNDS.map(() => ({
    finished:false, won:false, attempts:0, emoji:"", answer:"", definition:""
  }));

  function hintsAllowedThisRound() {
    return HINTS_BY_ROUND[roundIndex] ?? 1;
  }

  function setMessage(html){ msgEl.innerHTML = html; }

  function popTile(r,c){
    const t = tiles[r][c];
    t.classList.remove("pop");
    void t.offsetWidth;
    t.classList.add("pop");
  }

  function shakeRow(r){
    const rowEl = gridEl.children[r];
    rowEl.classList.remove("shake");
    void rowEl.offsetWidth;
    rowEl.classList.add("shake");
  }

  function buildGrid(){
    clearEl(gridEl);
    tiles = [];
    for (let r=0;r<MAX_ROWS;r++){
      const rowEl = document.createElement("div");
      rowEl.className = "row";
      rowEl.style.gridTemplateColumns = `repeat(${WORD_LEN}, 1fr)`;
      const rowTiles = [];
      for (let c=0;c<WORD_LEN;c++){
        const t = document.createElement("div");
        t.className = "tile";
        rowEl.appendChild(t);
        rowTiles.push(t);
      }
      gridEl.appendChild(rowEl);
      tiles.push(rowTiles);
    }
  }

  function render(){
    for (let r=0;r<MAX_ROWS;r++){
      for (let c=0;c<WORD_LEN;c++){
        tiles[r][c].textContent = guesses[r][c];
      }
    }
  }

  function firstEditableCol(start=0){
    for (let c=start;c<WORD_LEN;c++){
      if (!fixedPositions.has(c)) return c;
    }
    return WORD_LEN;
  }

  function lastEditableCol(start){
    for (let c=start;c>=0;c--){
      if (!fixedPositions.has(c)) return c;
    }
    return -1;
  }

  function initStateForRound(i){
    roundIndex = i;
    ANSWER = ROUNDS[i].answer.toUpperCase().replace(/[^A-Z]/g, "");
    WORD_LEN = ANSWER.length;

    row = 0; col = 0; done = false;
    hintsUsed = 0;
    fixedPositions = new Map();

    guesses = Array.from({length: MAX_ROWS}, () => Array(WORD_LEN).fill(""));

    roundPill.textContent = `Round ${i+1} / ${ROUNDS.length}`;
    subtitle.textContent = `${WORD_LEN} letters ‚Ä¢ Hints: ${hintsAllowedThisRound()}`;

    buildGrid();
    render();
    buildKeyboard();

    col = firstEditableCol(0);
    setMessage(`Type a <strong>${WORD_LEN}-letter</strong> guess, then press <strong>Enter</strong>.`);
    updateHintButton();
    focusInput();
  }

  function scoreGuess(guess, answer){
    const res = Array(WORD_LEN).fill("absent");
    const a = answer.split("");
    const g = guess.split("");

    for (let i=0;i<WORD_LEN;i++){
      if (g[i] === a[i]) { res[i]="correct"; a[i]=null; g[i]=null; }
    }
    for (let i=0;i<WORD_LEN;i++){
      if (!g[i]) continue;
      const idx = a.indexOf(g[i]);
      if (idx !== -1) { res[i]="present"; a[idx]=null; }
    }
    return res;
  }

  function buildEmojiForCurrentRound(){
    let out = [];
    const playedRows = Math.min(row + 1, MAX_ROWS);
    for (let r=0;r<playedRows;r++){
      const g = guesses[r].join("");
      if (g.length !== WORD_LEN) break;
      const s = scoreGuess(g, ANSWER);
      out.push(s.map(x => x==="correct"?"üü©":x==="present"?"üü®":"‚¨õ").join(""));
      if (g === ANSWER) break;
    }
    return out.join("\n");
  }

  function openModal(html, buttons){
    modalContent.innerHTML = html;
    clearEl(modalButtons);
    for (const b of buttons){
      const btn = document.createElement("button");
      btn.textContent = b.label;
      if (b.primary) btn.classList.add("primary");
      btn.addEventListener("click", b.onClick);
      modalButtons.appendChild(btn);
    }
    overlay.style.display = "flex";
    overlay.setAttribute("aria-hidden","false");
  }

  function closeModal(){
    overlay.style.display = "none";
    overlay.setAttribute("aria-hidden","true");
  }

  function showProgressModal({won}){
    const def = ROUNDS[roundIndex].definition;
    const emoji = buildEmojiForCurrentRound();

    roundResults[roundIndex] = {
      finished:true,
      won,
      attempts: (won ? row+1 : MAX_ROWS),
      emoji,
      answer: ANSWER,
      definition: def
    };

    const title = won ? "‚úÖ Nice!" : "‚ùå Out of tries";
    const attemptsLabel = won ? `Solved in ${row+1}/${MAX_ROWS}` : `Answer: ${ANSWER}`;

    const html = `
      <h2>${title}</h2>
      <div class="meta">${attemptsLabel}</div>
      <div class="cardbox"><div class="definition">${def}</div></div>
      <div class="cardbox">
        <div class="meta" style="margin-bottom:8px;">Your grid</div>
        <div class="emoji">${emoji || ""}</div>
      </div>
    `;

    const buttons = [
      {
        label: "Copy Round",
        onClick: async () => {
          try {
            await navigator.clipboard.writeText(`Wordle Round ${roundIndex+1}/${ROUNDS.length} (${ANSWER})\n${emoji}`);
            setMessage("Copied round result.");
          } catch {
            setMessage("Couldn‚Äôt copy.");
          }
        }
      }
    ];

    if (roundIndex < ROUNDS.length - 1) {
      buttons.push({
        label: "Next ‚Üí",
        primary: true,
        onClick: () => {
          closeModal();
          initStateForRound(roundIndex + 1);
        }
      });
    } else {
      buttons.push({
        label: "Finish ‚Üí Recap",
        primary: true,
        onClick: () => {
          closeModal();
          showFinalRecap();
        }
      });
    }

    openModal(html, buttons);
  }

  function buildAllShareText(){
    const parts = [];
    parts.push(`Wordle Sequence (${ROUNDS.length} rounds)`);
    for (let i=0;i<ROUNDS.length;i++){
      const r = roundResults[i];
      const ans = r.answer || ROUNDS[i].answer.toUpperCase();
      const emoji = (r.emoji || "").trim();
      const status = r.finished ? (r.won ? `${r.attempts}/6` : `X/6`) : "‚Äî";
      parts.push(`\nRound ${i+1}: ${ans}  ${status}`);
      if (emoji) parts.push(emoji);
    }
    parts.push("\n");
    return parts.join("\n");
  }

  function escapeHtml(s){
    return String(s).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
  }

  function showFinalRecap(){
    const blocks = roundResults.map((r, i) => {
      const ans = r.answer || ROUNDS[i].answer.toUpperCase();
      const status = r.finished ? (r.won ? `Solved in ${r.attempts}/6` : `Not solved (Answer: ${ans})`) : "Not played";
      return `
        <div class="cardbox">
          <div class="meta"><strong>Round ${i+1}:</strong> ${ans} ¬∑ ${status}</div>
          <div class="definition">${r.definition || ROUNDS[i].definition}</div>
          <div style="height:10px;"></div>
          <div class="emoji">${(r.emoji || "").trim()}</div>
        </div>
      `;
    }).join("");

    const fullShare = buildAllShareText();
    const html = `
      <h2>üéâ Recap</h2>
      <div class="meta">All words + definitions + your results.</div>
      ${blocks}
      <div class="cardbox">
        <div class="meta" style="margin-bottom:8px;">Copy-all text</div>
        <div class="emoji">${escapeHtml(fullShare)}</div>
      </div>
    `;

    openModal(html, [
      {
        label: "Copy All",
        primary: true,
        onClick: async () => {
          try {
            await navigator.clipboard.writeText(fullShare);
            setMessage("Copied all rounds.");
          } catch {
            setMessage("Couldn‚Äôt copy.");
          }
        }
      },
      {
        label: "Play Again",
        onClick: () => {
          closeModal();
          for (let i=0;i<roundResults.length;i++){
            roundResults[i] = {finished:false, won:false, attempts:0, emoji:"", answer:"", definition:""};
          }
          initStateForRound(0);
        }
      }
    ]);
  }

  // Hints
  function updateHintButton(){
    const remaining = Math.max(0, hintsAllowedThisRound() - hintsUsed);
    hintBtn.textContent = `HINT (${remaining})`;
    hintBtn.disabled = done || remaining <= 0 || fixedPositions.size >= WORD_LEN;
  }

  function revealHint(){
    if (done) return;
    if (hintsUsed >= hintsAllowedThisRound()) return;

    const candidates = [];
    for (let i=0;i<WORD_LEN;i++){
      if (!fixedPositions.has(i)) candidates.push(i);
    }
    if (!candidates.length) return;

    const pos = candidates[Math.floor(Math.random() * candidates.length)];
    const letter = ANSWER[pos];
    fixedPositions.set(pos, letter);
    hintsUsed++;

    for (let r=0;r<MAX_ROWS;r++){
      guesses[r][pos] = letter;
      tiles[r][pos].classList.add("hinted");
    }
    render();

    col = firstEditableCol(0);
    setMessage(`üí° Hint: position <strong>${pos+1}</strong> is <strong>${letter}</strong> (locked).`);
    updateHintButton();
    focusInput();
  }

  // Gameplay
  function lockInGuess(){
    if (guesses[row].some(ch => ch === "")) {
      setMessage(`Fill all <strong>${WORD_LEN}</strong> letters.`);
      shakeRow(row);
      return;
    }

    const guess = guesses[row].join("");
    if (!isValidWord(guess)) {
      setMessage("Letters only (A‚ÄìZ).");
      shakeRow(row);
      return;
    }

    const score = scoreGuess(guess, ANSWER);
    for (let c=0;c<WORD_LEN;c++){
      tiles[row][c].classList.add(score[c]);
    }

    if (guess === ANSWER) {
      done = true;
      setMessage("‚úÖ Correct!");
      updateHintButton();
      showProgressModal({won:true});
      return;
    }

    row++;
    col = firstEditableCol(0);

    if (row >= MAX_ROWS) {
      done = true;
      setMessage(`‚ùå Out of tries.`);
      updateHintButton();
      showProgressModal({won:false});
      return;
    }

    setMessage("Keep going.");
    focusInput();
  }

  function handleBackspace(){
    let prev = lastEditableCol(col - 1);
    if (prev === -1) return;
    col = prev;
    guesses[row][col] = "";
    render();
  }

  function handleLetter(ch){
    let c = col;
    while (c < WORD_LEN && fixedPositions.has(c)) c++;
    if (c >= WORD_LEN) return;

    guesses[row][c] = ch;
    popTile(row, c);
    render();

    col = firstEditableCol(c + 1);
  }

  // Unified handler for physical + on-screen keyboard
  function handleKey(k){
    if (overlay.style.display === "flex") return;
    if (done) return;

    if (k === "Enter") return lockInGuess();
    if (k === "‚å´") return handleBackspace();
    if (/^[A-Z]$/.test(k)) return handleLetter(k);
  }

  function focusInput(){
    try { ghostInput.focus({preventScroll:true}); } catch { ghostInput.focus(); }
  }

  // Desktop keyboard
  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape" && overlay.style.display === "flex") { closeModal(); return; }
    if (overlay.style.display === "flex") return;

    if (e.key === "Enter") { e.preventDefault(); return handleKey("Enter"); }
    if (e.key === "Backspace") { e.preventDefault(); return handleKey("‚å´"); }

    const up = e.key.toUpperCase();
    if (/^[A-Z]$/.test(up)) return handleKey(up);
  });

  // Mobile typing via hidden input
  ghostInput.addEventListener("input", () => {
    if (overlay.style.display === "flex") { ghostInput.value = ""; return; }
    if (done) { ghostInput.value = ""; return; }

    const v = ghostInput.value.toUpperCase().replace(/[^A-Z]/g, "");
    if (!v) { ghostInput.value = ""; return; }

    for (const ch of v) handleKey(ch);
    ghostInput.value = "";
  });

  // Tap the card to bring up mobile keyboard
  gameCard.addEventListener("pointerdown", () => focusInput());

  // On-screen keyboard build
  const KB_LAYOUT = ["QWERTYUIOP","ASDFGHJKL","ZXCVBNM"];
  function addKey(el, label, wide=false){
    const b = document.createElement("button");
    b.className = "key" + (wide ? " wide" : "");
    b.type = "button";
    b.textContent = label;
    b.addEventListener("click", () => {
      focusInput();
      handleKey(label);
    });
    el.appendChild(b);
  }

  function buildKeyboard(){
    kb1.innerHTML = ""; kb2.innerHTML = ""; kb3.innerHTML = "";
    for (const c of KB_LAYOUT[0]) addKey(kb1, c);
    for (const c of KB_LAYOUT[1]) addKey(kb2, c);
    addKey(kb3, "Enter", true);
    for (const c of KB_LAYOUT[2]) addKey(kb3, c);
    addKey(kb3, "‚å´", true);
  }

  // Buttons
  hintBtn.addEventListener("click", () => { focusInput(); revealHint(); });

  copyBtn.addEventListener("click", async () => {
    try {
      const emoji = done ? buildEmojiForCurrentRound() : "(finish the round to get the grid)";
      await navigator.clipboard.writeText(`Wordle Round ${roundIndex+1}/${ROUNDS.length} (${ANSWER})\n${emoji}`);
      setMessage("Copied round result.");
    } catch {
      setMessage("Couldn‚Äôt copy.");
    }
  });

  copyAllBtn.addEventListener("click", async () => {
    try {
      await navigator.clipboard.writeText(buildAllShareText());
      setMessage("Copied all rounds.");
    } catch {
      setMessage("Couldn‚Äôt copy.");
    }
  });

  resetBtn.addEventListener("click", () => initStateForRound(roundIndex));

  // Start
  initStateForRound(0);
})();
</script>
</body>
</html>
